package com.artogco.happy2be.service;


import ai.djl.huggingface.tokenizers.HuggingFaceTokenizer;
import ai.djl.modality.Classifications;
import ai.djl.ndarray.NDArray;
import ai.djl.ndarray.NDList;
import ai.djl.ndarray.NDManager;
import ai.djl.translate.Batchifier;
import ai.djl.translate.TranslateException;
import ai.djl.translate.Translator;
import ai.djl.translate.TranslatorContext;
import java.util.ArrayList;
import java.util.List;
/**
 * Interface 
 * When we implement an interface like Translator, we need to override its abstract methods. The methods must match the signature defined in the interface, which is why you need to ensure that the parameters and return types align.
 * In DJL, the processInput method receives a String (the raw input text) and returns an NDList. Similarly, processOutput receives an NDList (the output from the model) and returns a Classifications object.
 * This is not working due to the model tbd if integrate  in  future -- use python(happyfaceflask) and an http java injestion instead. 
 */
public class DistilBertTranslator implements Translator<String, Classifications> {

    private HuggingFaceTokenizer tokenizer;

    public DistilBertTranslator() {
        try {
            tokenizer = HuggingFaceTokenizer.newInstance("distilbert-base-uncased");
            System.out.println("Tokenizer loaded successfully!");
        } catch (Exception e) {
            System.err.println("Tokenizer failed to load: " + e.getMessage());
        }
    }
    /*@Override
    public Input processInput(TranslatorContext ctx, String input) throws TranslateException {
        // Implement processInput if needed
    }*/
    /*
    @Override
    public Classifications processOutput(TranslatorContext ctx, Output output) throws TranslateException {
        List<String> classNames = List.of("NEGATIVE", "POSITIVE"); // Adjust based on your model labels
       // return new Classifications(classNames, NlpUtils.toFloatArray(output));

        // Get the NDArray (tensor) from the output
        NDArray probabilityArray =(NDArray) output.getData();

        // Convert the probabilities to a list of class labels (e.g., "POSITIVE", "NEGATIVE")
        
        // Get the predicted class
        float[] probabilities = probabilityArray.toFloatArray();

        // Convert the float[] to a List<Double> (required by the constructor)
        List<Double> probabilityList = new ArrayList<>();
        for (float prob : probabilities) {
            probabilityList.add((double) prob); // Convert each float to double
        }



        int predictedIndex = getMaxIndex(probabilities);
        return new Classifications(classNames, probabilityList);



    }*/
    /*
     *  This method processes the output generated by the model and converts it into a more usable format, like class predictions.
     * receives an NDList (the output from the model) and returns a Classifications object.
     * The purpose of processOutput is to take the raw output from the model (usually in the form of a tensor) and convert it into a usable format, such as probabilities or predicted classes.
     * The model's output comes as an NDList, which contains an NDArray (a tensor). We need to extract the tensor from this list.
     * We then convert the tensor into an array of floats, which represent the probabilities of different classes. We find the class with the highest probability and map it to a list of labels (e.g., "NEGATIVE", "POSITIVE").
     * Finally, we return a Classifications object that holds the class names and their corresponding probabilities.v
     */
    @Override
    public Classifications processOutput(TranslatorContext ctx, NDList list) throws TranslateException {
        List<String> classNames = List.of("NEGATIVE", "POSITIVE"); // Adjust based on your model labels binary sentiment model.

        // Get the NDArray (tensor) from the NDList
        NDArray probabilityArray = list.singletonOrThrow();  // Get the first NDArray from the list

        // Convert the probabilities to a list of class labels (e.g., "POSITIVE", "NEGATIVE")
        float[] probabilities = probabilityArray.toFloatArray();

        // Convert the float[] to a List<Double> (required by the constructor)
        List<Double> probabilityList = new ArrayList<>();
        for (float prob : probabilities) {
            probabilityList.add((double) prob); // Convert each float to double
        }

        //int predictedIndex = getMaxIndex(probabilities);
        return new Classifications(classNames, probabilityList);
    }


/*
 * This method processes the input text and converts it into a format that can be fed to a machine learning model.
 * In DJL, the processInput method receives a String (the raw input text) and returns an NDList
 * 
 * The purpose of processInput is to take the raw text (string) and convert it into a format the model can use. In our case, the model needs tokenized input, which is represented as a series of token IDs.
 * We use the Hugging Face tokenizer to tokenize the input, which gives us a list of token IDs.
 * This list is then wrapped in an NDArray (a multidimensional array) to represent the tensor the model can process. DJL expects the input to be in the form of an NDList (a list of NDArray objects), so we return the NDList containing our input tensor.
 * 
 */
    @Override
    public NDList processInput(TranslatorContext ctx, String input) throws TranslateException {
        // Convert input text into a tensor (NDArray)
        NDManager manager = ctx.getNDManager();
        // Assuming the text needs to be tokenized first. Adjust accordingly for the model you're using.
        // Here we're creating a dummy NDArray for simplicity. Replace this with proper tokenization.

        // Tokenize the input text
        long[] tokenIds = tokenizer.encode(input).getIds();

        // Convert the tokenized input into an NDArray
        NDArray inputArray = manager.create(tokenIds);
        // Wrap the input array into an NDList (this is the expected type)
        NDList ndList = new NDList(inputArray);
        return ndList;


    }

    @Override
    public Batchifier getBatchifier() {
        return null;
    }

    // Helper method to find the index of the max probability
    private int getMaxIndex(float[] probabilities) {
        int maxIndex = 0;
        for (int i = 1; i < probabilities.length; i++) {
            if (probabilities[i] > probabilities[maxIndex]) {
                maxIndex = i;
            }
        }
        return maxIndex;
    }



}